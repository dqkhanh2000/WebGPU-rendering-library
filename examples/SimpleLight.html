<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Render cube</title>
    <style>
        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            text-align: center;
            flex-direction: column;
            justify-content: center;
        }
        p{
            font-size: 14px;
            margin:0
        }
        canvas {
            width: 100%;
            height: 100%; 
        }
    </style>
</head>
<body>
    <canvas></canvas>
    <script type="module">
      import * as WebGPULibrary from "../src/index.js";

      const canvas = document.querySelector("canvas");

      const camera = new WebGPULibrary.PerspectiveCamera({
        position: new WebGPULibrary.Vector3(60, 0, 60),
        lookAt: new WebGPULibrary.Vector3(0, 0, 0),
        fov: 60
      });
      const renderer = new WebGPULibrary.Renderer({ canvas, camera });
      const controls = new WebGPULibrary.OrbitControl(camera, canvas);

      renderer.onUpdate(() => {
        controls.update();
      });

      let ambientLight = new WebGPULibrary.AmbientLight({ intensity: 0.2, color: WebGPULibrary.Color.WHITE });
      renderer.addLight(ambientLight);

      let directionLight = new WebGPULibrary.DirectionLight({
        direction: new WebGPULibrary.Vector3(0, 1, 0),
        intensity: 0.3,
        color: WebGPULibrary.Color.WHITE
      });
      renderer.addLight(directionLight);
      let directionLightMesh = new WebGPULibrary.Mesh({
        geometry: new WebGPULibrary.CylinderGeometry(0.2),
        material: new WebGPULibrary.NormalMaterial()
      });
      directionLightMesh.scale.set(3, 3, 3);
      directionLightMesh.position.set(0, 0, 30);
      renderer.scene.add(directionLightMesh);


      let pointLight = new WebGPULibrary.PointLight({
        radius: 20,
        position: new WebGPULibrary.Vector3(0, 0, 0),
        intensity: 1,
        color: WebGPULibrary.Color.WHITE
      });
      renderer.addLight(pointLight);
      let pointLightMesh = new WebGPULibrary.Mesh({
        geometry: new WebGPULibrary.SphereGeometry(),
        material: new WebGPULibrary.NormalMaterial()
      });
      pointLightMesh.scale.set(0.3, 0.3, 0.3);
      renderer.scene.add(pointLightMesh);

      let materials = [
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.RED}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.GREEN}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.BLUE}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.YELLOW}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.PURPLE}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.MAGENTA}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.CYAN}),
        new WebGPULibrary.LambertMaterial({ albedo: WebGPULibrary.Color.GRAY}),
      ];

      let geometries = [
        new WebGPULibrary.BoxGeometry(),
        new WebGPULibrary.SphereGeometry(0.5),
        new WebGPULibrary.CylinderGeometry(0.2),
        new WebGPULibrary.LatheGeometry(),
        new WebGPULibrary.CapsuleGeometry(0.5),
      ]

      let numberOfObject = 500;
      for(let i = 0; i < numberOfObject; i++){
        let geometry = geometries[Math.floor(Math.random() * geometries.length)];
        let material = materials[Math.floor(Math.random() * materials.length)];
        let mesh = new WebGPULibrary.Mesh({geometry, material});
        // random position in a sphere with radius is 30
        mesh.position.set(
          Math.random() * 30 - 15,
          Math.random() * 30 - 15,
          Math.random() * 30 - 15
        );
        mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
        renderer.scene.add(mesh);
      }

      renderer.onUpdate(() => {
        let renderTime = Date.now() / 1000;
        pointLight.position.set(Math.sin(renderTime) * 10, 0, Math.cos(renderTime) * 10);
        pointLightMesh.position.set(Math.sin(renderTime) * 10, 0, Math.cos(renderTime) * 10);
        directionLight.direction.set(Math.sin(renderTime), 0, Math.cos(renderTime));
        directionLightMesh.rotation.set(-Math.sin(renderTime), 0, -Math.cos(renderTime));
      });

      renderer.start();
    </script>
</body>
</html>